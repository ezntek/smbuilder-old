use crate::prelude::{get_makeopts_string, make_file_executable};
use derive_builder::Builder;
use std::fmt::{Debug, Display};
use std::fs;
use std::io::Write;
use std::path::Path;

use serde::{Deserialize, Serialize};
use std::path::PathBuf;

#[cfg(test)]
mod tests {
    use std::path::PathBuf;

    use crate::prelude::Makeopt;

    use super::{Region, Repo, Rom, Spec, SpecBuilder};

    #[test]
    fn test_deser() {
        let file_spec = "
rom:
    region: us
    path: ./rom.z64
      
repo:
    name: sm64ex
    url: 'https://github.com/sm64pc/sm64ex'
    branch: nightly
    supports_packs: false
    supports_textures: false
    
additional_makeopts:
    - key: DISCORDRPC
      value: '0'
";

        let spec = serde_yaml::from_str::<Spec>(file_spec).unwrap();
        println!("{:?}", spec);
    }

    #[test]
    fn test_ser() {
        let r = Rom {
            region: Region::EU,
            path: PathBuf::from("./rom.z64"),
        };

        let re = Repo {
            name: String::from("rastarstarst"),
            url: String::from("https://github.com/my/repo.link"),
            branch: String::from("mybranch"),
            supports_packs: false,
            supports_textures: false,
        };

        let s = Spec {
            rom: r,
            repo: re,
            jobs: None,
            name: None,
            additional_makeopts: Some(vec![Makeopt {
                key: "hi".to_owned(),
                value: "hii".to_owned(),
            }]),
            texture_pack: None,
            packs: None,
        };

        let res = serde_yaml::to_string(&s).unwrap();
        println!("{}", res);
    }
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum Region {
    #[default]
    US,
    EU,
    JP,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Rom {
    pub region: Region,
    pub path: PathBuf,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Repo {
    pub name: String,
    pub url: String,
    pub branch: String,
    pub supports_packs: bool,
    pub supports_textures: bool,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Makeopt {
    pub key: String,
    pub value: String,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Datapack {
    pub label: String,
    pub path: PathBuf,
    pub enabled: bool,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TexturePack {
    pub path: PathBuf,
    pub enabled: bool,
}

#[derive(Default, Builder, Debug, Deserialize, Serialize)]
#[builder(setter(into))]
pub struct Spec {
    pub rom: Rom,
    pub repo: Repo,
    pub jobs: Option<u8>,
    pub name: Option<String>,
    pub additional_makeopts: Option<Vec<Makeopt>>,
    pub texture_pack: Option<TexturePack>,
    pub packs: Option<Vec<Datapack>>,
}

impl Spec {
    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Spec, String> {
        let file_string = match fs::read_to_string(&path) {
            Ok(s) => s,
            Err(e) => return Err(format!("Failed to read the file: {}", e)),
        };

        println!("\nFILE:\n\n{}\n", &file_string);

        let retval = match serde_yaml::from_str::<Spec>(&file_string) {
            Ok(s) => s,
            Err(e) => return Err(format!("Failed to parse the file into a yaml: {}", e)),
        };

        Ok(retval)
    }

    pub fn get_build_script(&self, repo_path: &Path) -> String {
        let makeopts_string = if let Some(makeopts) = &self.additional_makeopts {
            get_makeopts_string(makeopts)
        } else {
            String::new()
        };

        let jobs = if let Some(j) = self.jobs { j } else { 2 };

        format!(
            "
#!/bin/sh

echo \"Script Generated by smbuilder.\"
echo \"DO NOT EDIT; YOUR CHANGES WILL NOT\"
echo \"BE SAVED.\"

make -C {} {} -j{}
        ",
            repo_path.display(),
            makeopts_string,
            jobs
        )
    }

    pub fn write_build_script(&self, repo_path: &Path) -> Result<(), String> {
        let script = self.get_build_script(repo_path);

        let base_path = match repo_path.parent() {
            Some(base_path) => Ok(base_path.to_path_buf()),
            None => Err("the repository path somehow has no parent directory!"), // early return #1
        };

        let build_script_path = match base_path {
            Ok(path) => path,
            Err(e) => return Err(e.to_string()), // return whatever I wrote above
        };

        let mut build_script_file = match fs::File::create(&build_script_path) {
            Ok(file) => file,
            Err(e) => {
                return Err(format!(
                    "failed to create file at {}: {}",
                    &build_script_path.display(),
                    e
                ))
            } // early return #2
        };

        match build_script_file.write(script.as_bytes()) {
            Ok(_) => (),
            Err(e) => {
                return Err(format!(
                    "failed to write file at {}: {}",
                    &build_script_path.display(),
                    e
                ))
            } // early return #3
        };

        match make_file_executable(&build_script_path) {
            Ok(_) => Ok(()),
            Err(e) => Err(e),
        }
    }
}
