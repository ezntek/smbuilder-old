use crate::prelude::*;
use crate::romconvert::determine_format;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

#[derive(Debug, Deserialize, Serialize)]
/// Represents a build spec.
///
/// All of its child structs implements
/// `Deserialize` and `Serialize`, and a
/// spec file is derived directly from this
/// structure.
pub struct Spec {
    /// The ROM to extract assets out of.
    pub rom: Rom,
    /// The repository to build from.
    pub repo: Repo,
    /// Amount of compile jobs that are
    /// allowed for the compiler. Will
    /// be used to set the `-j` flag
    /// during compile time.
    pub jobs: Option<u8>,
    /// A custom name.
    pub name: Option<String>,
    /// Make flags to be passed to the
    /// compiler.
    pub makeopts: Option<Vec<Makeopt>>,
    /// DynOS packs, if supported.
    pub packs: Option<Vec<DynosPack>>,
    /// Patches.
    pub patches: Option<Vec<Patch>>,
    /// Post install scripts.
    pub scripts: Option<Vec<PostBuildScript>>,
}

// TODO: write a SpecBuilder
impl Spec {
    /// # Please do not use this.
    ///
    /// **
    /// It's only for users of
    /// this crate that will perform
    /// checks themselves, or
    /// masochists!
    /// **
    ///
    /// Creates a new spec, from a file,
    /// but **doesn't check it**, which **may
    /// lead to random panics**
    ///
    /// # Example
    /// `Hey, you. why are you here? You shouldn't be using this at all!`
    pub fn from_file_unchecked<P: AsRef<Path>>(path: P) -> Result<Spec, SmbuilderError> {
        let file_string = match fs::read_to_string(&path) {
            Ok(s) => s,
            Err(e) => {
                return Err(SmbuilderError::new(
                    Some(Box::new(e)),
                    "Failed to read the file",
                ))
            }
        };

        let retval = match serde_yaml::from_str::<Spec>(&file_string) {
            Ok(s) => s,
            Err(e) => {
                return Err(SmbuilderError::new(
                    Some(Box::new(e)),
                    "Failed to parse the file into a yaml",
                ))
            }
        };

        Ok(retval)
    }

    pub fn check_spec(&mut self, callbacks: &mut Callbacks) -> Result<(), SmbuilderError> {
        use LogType::*;

        // Check the ROM format and see
        // if it matches the spec
        let rom_path = if self.rom.path.exists() {
            &self.rom.path
        } else {
            let file_not_found_error = std::io::Error::new(
                std::io::ErrorKind::NotFound,
                format!("the file at {} was not found!", &self.rom.path.display()),
            );
            return Err(SmbuilderError::new(
                Some(Box::new(file_not_found_error)),
                "the ROM at the given path was not found!",
            ));
        };

        let verified_rom_format = match determine_format(rom_path) {
            Ok(t) => t,
            Err(e) => {
                return Err(SmbuilderError::new(
                    Some(Box::new(e)),
                    "failed to verify the ROM's format",
                ))
            }
        };

        if verified_rom_format != self.rom.format {
            run_callback!(
                callbacks.log_cb,
                Warn,
                &format!(
                    "the ROM format specified in the spec ({:?}) does not match the file ({:?})!",
                    self.rom.format, verified_rom_format
                )
            );
        };

        // Repo
        // TODO: finnish writing the repo metadata first

        // Jobs

        if self.jobs.is_none() {
            run_callback!(
                callbacks.log_cb,
                Warn,
                "did not find a value for jobs in the spec!"
            );

            run_callback!(
                callbacks.log_cb,
                Warn,
                "it is highly advised for you to specify the variable!"
            );
        }

        Ok(())
    }

    // TODO: write a from_file function that checks

    /// Gets a build shell script, ready to be
    /// written to disk.
    ///
    /// TODO: example

    pub fn get_build_script(&self, repo_path: &Path) -> String {
        let makeopts_string = if let Some(makeopts) = &self.makeopts {
            get_makeopts_string(makeopts)
        } else {
            String::new()
        };

        // FreeBSD, macOS and OSes
        // with BSD make by default
        let make_cmd = "gmake";

        #[cfg(target_os = "linux")]
        let make_cmd = "make";

        let platform_makeopts = get_makeopts_string(&Makeopt::default_platform_makeopts());

        let jobs = self.jobs.unwrap_or(2);

        format!(
            "
#!/bin/sh

# Script Generated by smbuilder.
# DO NOT EDIT; YOUR CHANGES
# WILL NOT BE SAVED.

{} -C {} {} {} -j{}
        ",
            make_cmd,
            repo_path.display(),
            platform_makeopts,
            makeopts_string,
            jobs
        )
    }
}
